{
    parserClass="de.qrdn.coco_idea.CocoParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Coco"
    psiImplClassSuffix="Impl"
    psiPackage="de.qrdn.coco_idea.psi"
    psiImplPackage="de.qrdn.coco_idea.psi.impl"

    elementTypeHolderClass="de.qrdn.coco_idea.psi.CocoTypes"
    elementTypeClass="de.qrdn.coco_idea.psi.CocoElementType"
    tokenTypeClass="de.qrdn.coco_idea.psi.CocoTokenType"

    psiImplUtilClass="de.qrdn.coco_idea.psi.impl.CocoPsiImplUtil"

    // tokens are recognized by JFlex lexer, definitions here are only informative / for testing
    tokens = [
        COMPILER_KEYWORD="COMPILER"
        IGNORECASE_KEYWORD="IGNORECASE"
        CHARACTERS_KEYWORD="CHARACTERS"
        TOKENS_KEYWORD="TOKENS"
        PRAGMAS_KEYWORD="PRAGMAS"
        COMMENTS_KEYWORD="COMMENTS"
        FROM_KEYWORD="FROM"
        TO_KEYWORD="TO"
        NESTED_KEYWORD="NESTED"
        IGNORE_KEYWORD="IGNORE"
        PRODUCTIONS_KEYWORD="PRODUCTIONS"
        END_KEYWORD="END"
        EQUALS  = "="
        DOT     = "."
        PLUS    = "+"
        MINUS   = "-"
        DOTDOT  = ".."
        OR      = "|"
        ANY_KEYWORD="ANY"
        WEAK_KEYWORD="WEAK"
        LPAREN  = "("
        RPAREN  = ")"
        LSPAREN = "["
        RSPAREN = "]"
        LAPAREN = "{"
        RAPAREN = "}"
        SYNC_KEYWORD="SYNC"
        CONTEXT_KEYWORD="CONTEXT"
        resolver="IF(.*)"

        ident='regexp:[a-zA-Z_][a-zA-Z_0-9]*'
        string='regexp:"[^"]*?"'
        character="regexp:'([^\'\\\n\r]|\\\'|\\[\u0020-\u0026\u0028-\u007e]*)'"
        comment='regexp://.*$|/\*.*\*/' // |\(\..*\.\)
        space='regexp:\s'

        INSTRUMENTATION_CODE='regexp:[^]'
        INSTRUMENTATION_CODE_PARENDOT='regexp:(\.[^]*\.)'
        INSTRUMENTATION_CODE_ANGLE='regexp:<[^]*>'
        INSTRUMENTATION_CODE_ANGLEDOT='regexp:<\.[^]*\.>'
    ]

    // CocoNamedElement used for reference resolution
    mixin("set_decl|token_decl|production")="de.qrdn.coco_idea.psi.impl.CocoNamedElementImpl"
    implements("set_decl|token_decl|production")="de.qrdn.coco_idea.psi.CocoNamedElement"
    methods("set_decl|token_decl|production")=[getName setName getPresentation getNameIdentifier]
    // CocoFileSection used for StructureView
    mixin("CHARACTERS|TOKENS|PRODUCTIONS")="de.qrdn.coco_idea.psi.impl.CocoFileSectionImpl"
    implements("CHARACTERS|TOKENS|PRODUCTIONS")="de.qrdn.coco_idea.psi.CocoFileSection"
    methods("CHARACTERS|TOKENS|PRODUCTIONS")=[getDeclarations getPresentation]
    // CocoInstrumentationCode used for instrumentation Language Injection
    mixin("include_header")="de.qrdn.coco_idea.psi.impl.CocoIncludeHeaderImpl"
    mixin("global_decls")="de.qrdn.coco_idea.psi.impl.CocoGlobalDeclsImpl"
    mixin("attribs")="de.qrdn.coco_idea.psi.impl.CocoAttribsImpl"
    mixin("sem_text")="de.qrdn.coco_idea.psi.impl.CocoSemTextImpl"
    mixin("attr_decl")="de.qrdn.coco_idea.psi.impl.CocoAttrDeclImpl"
    mixin("resolver_rule")="de.qrdn.coco_idea.psi.impl.CocoResolverImpl"
    implements("include_header|global_decls|attribs|sem_text|attr_decl|resolver_rule")="de.qrdn.coco_idea.psi.CocoInstrumentationCode"
}

//TODO: more pin, recoverWhile attributes to parse broken files

coco_file ::=
    include_header
    compiler_decl
    global_decls
    scanner_spec
    parser_spec
    end_statement
  {pin=5}

private compiler_decl ::= COMPILER_KEYWORD ident_rule
  {pin=1}

private scanner_spec ::=
    [ IGNORECASE_KEYWORD ]
    [ CHARACTERS ]
    [ TOKENS ]
    [ pragmas ]
    comment_spec*
    ignore_spec*
  {pin=3}

private include_header ::= INSTRUMENTATION_CODE
private global_decls ::= INSTRUMENTATION_CODE
private parser_spec ::= PRODUCTIONS
private pragmas ::= PRAGMAS_KEYWORD token_decl*
  {pin=1}
private comment_spec ::= COMMENTS_KEYWORD FROM_KEYWORD token_expr TO_KEYWORD token_expr NESTED_KEYWORD?
  {pin=1}
private ignore_spec ::= IGNORE_KEYWORD set
  {pin=1}
private end_statement ::= END_KEYWORD ident_rule '.'
  {pin=1}

CHARACTERS ::= CHARACTERS_KEYWORD set_decl*
  {pin=1}
TOKENS ::= TOKENS_KEYWORD token_decl*
  {pin=1}
PRODUCTIONS ::= PRODUCTIONS_KEYWORD production*
  {pin=1}

set_decl ::= ident_rule '=' set '.'
  {pin=4}
set ::= sim_set ('+' sim_set | '-' sim_set)*
sim_set ::= ident_rule | string | character ['..' character] | ANY_KEYWORD
token_decl ::= sym [ '=' token_expr '.' ] [ sem_text ]
private attr_decl ::= INSTRUMENTATION_CODE_ANGLE | INSTRUMENTATION_CODE_ANGLEDOT
expression ::= term ( '|' term )*
term ::= ( [resolver_rule] factor factor* )?
factor ::=
        [ WEAK_KEYWORD ]
        sym
        [ attribs ]
    | '(' expression ')'
    | '[' expression ']'
    | '{' expression '}'
    | ANY_KEYWORD
    | SYNC_KEYWORD
    | sem_text
token_expr ::= token_term ( '|' token_term )*
  {pin=1}
token_term ::= token_factor token_factor* [ CONTEXT_KEYWORD '(' token_expr ')' ]
  {pin=1}
token_factor ::=
        sym
    | '(' token_expr ')'
    | '[' token_expr ']'
    | '{' token_expr '}'
sym ::= ( ident_rule | string | character )
private attribs ::= INSTRUMENTATION_CODE_ANGLE | INSTRUMENTATION_CODE_ANGLEDOT
private sem_text ::= INSTRUMENTATION_CODE_PARENDOT
production ::= ident_rule attr_decl? sem_text? '=' expression '.'
  {pin=4}

// rules needed only so we have a Psi*Impl class
ident_rule ::= ident
resolver_rule ::= resolver
